import { Room } from "livekit-client";
export interface StreamingAvatarApiConfig {
    token: string;
    basePath?: string;
}
export declare enum AvatarQuality {
    Low = "low",
    Medium = "medium",
    High = "high"
}
export declare enum VoiceEmotion {
    EXCITED = "excited",
    SERIOUS = "serious",
    FRIENDLY = "friendly",
    SOOTHING = "soothing",
    BROADCASTER = "broadcaster"
}
export interface StartAvatarRequest {
    quality?: AvatarQuality;
    avatarName: string;
    voice?: {
        voiceId?: string;
        rate?: number;
        emotion?: VoiceEmotion;
    };
    knowledgeId?: string;
    language?: string;
    knowledgeBase?: string;
    disableIdleTimeout?: boolean;
}
export interface StartAvatarResponse {
    session_id: string;
    access_token: string;
    url: string;
    is_paid: boolean;
    session_duration_limit: number;
}
export declare enum TaskType {
    TALK = "talk",
    REPEAT = "repeat"
}
export declare enum TaskMode {
    SYNC = "sync",
    ASYNC = "async"
}
export interface SpeakRequest {
    text: string;
    task_type?: TaskType;
    taskType?: TaskType;
    taskMode?: TaskMode;
}
export interface CommonRequest {
    [key: string]: any;
}
export declare enum StreamingEvents {
    AVATAR_START_TALKING = "avatar_start_talking",
    AVATAR_STOP_TALKING = "avatar_stop_talking",
    AVATAR_TALKING_MESSAGE = "avatar_talking_message",
    AVATAR_END_MESSAGE = "avatar_end_message",
    USER_TALKING_MESSAGE = "user_talking_message",
    USER_END_MESSAGE = "user_end_message",
    USER_START = "user_start",
    USER_STOP = "user_stop",
    USER_SILENCE = "user_silence",
    STREAM_READY = "stream_ready",
    STREAM_DISCONNECTED = "stream_disconnected"
}
export type EventHandler = (...args: any[]) => void;
export interface EventData {
    [key: string]: unknown;
    task_id: string;
}
export interface StreamingStartTalkingEvent extends EventData {
    type: StreamingEvents.AVATAR_START_TALKING;
}
export interface StreamingStopTalkingEvent extends EventData {
    type: StreamingEvents.AVATAR_STOP_TALKING;
}
export interface StreamingTalkingMessageEvent extends EventData {
    type: StreamingEvents.AVATAR_TALKING_MESSAGE;
    message: string;
}
export interface StreamingTalkingEndEvent extends EventData {
    type: StreamingEvents.AVATAR_END_MESSAGE;
}
export interface UserTalkingMessageEvent extends EventData {
    type: StreamingEvents.USER_TALKING_MESSAGE;
    message: string;
}
export interface UserTalkingEndEvent extends EventData {
    type: StreamingEvents.USER_END_MESSAGE;
}
declare class StreamingAvatar {
    room: Room | null;
    mediaStream: MediaStream | null;
    private readonly token;
    private readonly basePath;
    private eventTarget;
    private audioContext;
    private webSocket;
    private scriptProcessor;
    private mediaStreamAudioSource;
    private mediaDevicesStream;
    private audioRawFrame;
    private sessionId;
    private language;
    constructor({ token, basePath, }: StreamingAvatarApiConfig);
    createStartAvatar(requestData: StartAvatarRequest): Promise<any>;
    startVoiceChat(requestData?: {
        useSilencePrompt?: boolean;
    }): Promise<void>;
    closeVoiceChat(): void;
    newSession(requestData: StartAvatarRequest): Promise<StartAvatarResponse>;
    startSession(): Promise<any>;
    speak(requestData: SpeakRequest): Promise<any>;
    startListening(): Promise<any>;
    stopListening(): Promise<any>;
    interrupt(): Promise<any>;
    stopAvatar(): Promise<any>;
    on(eventType: string, listener: EventHandler): this;
    off(eventType: string, listener: EventHandler): this;
    private request;
    private emit;
    private getRequestUrl;
    private connectWebSocket;
    private loadAudioRawFrame;
}
export default StreamingAvatar;
